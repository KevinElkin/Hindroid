{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Assignments 2 and 3 Notebook"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import requests\n",
    "from bs4 import BeautifulSoup\n",
    "import urllib.request\n",
    "import numpy as np\n",
    "from collections import defaultdict\n",
    "import simplejson as json\n",
    "import collections\n",
    "import pandas as pd\n",
    "from sklearn.linear_model import LogisticRegression\n",
    "import matplotlib.pyplot as plt\n",
    "from sklearn.ensemble import RandomForestClassifier\n",
    "from sklearn.ensemble import GradientBoostingClassifier\n",
    "from sklearn.metrics import classification_report\n",
    "from sklearn.metrics import recall_score\n",
    "from sklearn.metrics import f1_score\n",
    "import random\n",
    "import glob\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.metrics import confusion_matrix\n",
    "import io\n",
    "from sklearn.svm import LinearSVC\n",
    "import gzip\n",
    "import random\n",
    "import os\n",
    "import itertools\n",
    "import pathlib\n",
    "import re \n",
    "from scipy import sparse\n",
    "from sklearn import svm\n",
    "from scipy.stats import uniform\n",
    "from tqdm import tqdm"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'/home/kelkin/EDA/APK_Downloads/'"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "'''\n",
    "A method that creates the necessary file structure that will be used to\n",
    "store the APK downloads\n",
    "'''\n",
    "\n",
    "def createDir():\n",
    "\n",
    "    cwd = os.getcwd()\n",
    "    file = str(cwd) + '/EDA'\n",
    "    file2 = file + '/APK_Downloads/'\n",
    "\n",
    "    if os.path.isdir(file) == False:\n",
    "        os.mkdir(file)\n",
    "        if os.path.isdir(file2) == False:\n",
    "            os.mkdir(file2)\n",
    "\n",
    "    return file2\n",
    "\n",
    "PATH = createDir()\n",
    "PATH"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# To get the same amount of malware apps \n",
    "\n",
    "def countBenign(dic):\n",
    "    List_flat = list(itertools.chain(*dic.values()))\n",
    "    return len(List_flat)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'.ipynb_checkpoints': [],\n",
       " 'tools': ['tools_31',\n",
       "  'tools_0',\n",
       "  'tools_22',\n",
       "  'tools_28',\n",
       "  'tools_17',\n",
       "  'tools_41',\n",
       "  'tools_32',\n",
       "  'tools_3',\n",
       "  'tools_13',\n",
       "  'tools_14',\n",
       "  'tools_42',\n",
       "  'tools_35',\n",
       "  'tools_40',\n",
       "  'tools_16',\n",
       "  'tools_24',\n",
       "  'tools_23',\n",
       "  'tools_11',\n",
       "  'tools_30',\n",
       "  '.ipynb_checkpoints',\n",
       "  'tools_1',\n",
       "  'tools_34',\n",
       "  'tools_15',\n",
       "  'tools_20',\n",
       "  'tools_18',\n",
       "  'tools_39',\n",
       "  'tools_44'],\n",
       " 'comics': ['comics_22',\n",
       "  'comics_28',\n",
       "  'comics_31',\n",
       "  'comics_25',\n",
       "  'comics_2',\n",
       "  'comics_17',\n",
       "  'comics_6',\n",
       "  'comics_19',\n",
       "  'comics_13',\n",
       "  'comics_21',\n",
       "  '.ipynb_checkpoints',\n",
       "  'comics_26',\n",
       "  'comics_14',\n",
       "  'comics_1',\n",
       "  'comics_3',\n",
       "  'comics_16',\n",
       "  'comics_30',\n",
       "  'comics_11',\n",
       "  'comics_4',\n",
       "  'comics_29',\n",
       "  'comics_27',\n",
       "  'comics_15',\n",
       "  'comics_0',\n",
       "  'comics_7',\n",
       "  'comics_12',\n",
       "  'comics_20']}"
      ]
     },
     "execution_count": 23,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#get immediate subdirectories of each subdirectories from above. Key is the catagory of app and value is the app name\n",
    "#gives you all the apps for a given catagory\n",
    "\n",
    "def catagoryApps(path):\n",
    "    \n",
    "    #get immediate subdirectories of PATH \n",
    "    list_subfolders_with_paths = [f.path for f in os.scandir(PATH) if f.is_dir()]\n",
    "    directDic = {}\n",
    "\n",
    "    for direct in list_subfolders_with_paths:\n",
    "        subdirs = []\n",
    "        for sub in os.scandir(direct):\n",
    "            if sub.is_dir():\n",
    "                subdirs.append(sub.name)\n",
    "        directDic[direct.split(\"/\")[-1]] = subdirs\n",
    "\n",
    "    return directDic\n",
    "\n",
    "directDic = catagoryApps(PATH)\n",
    "directDic"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "# def malware_app_paths():\n",
    "#     malware_loc = []\n",
    "#     dir_list = os.listdir(\"/datasets/dsc180a-wi20-public/Malware/amd_data_smali\")\n",
    "#     for i in dir_list:\n",
    "#         string = '/datasets/dsc180a-wi20-public/Malware/amd_data_smali/' + i\n",
    "#         lis = os.listdir(string)\n",
    "#         for variety in lis:\n",
    "#             new_string = string + '/' + variety\n",
    "#             app_list = os.listdir(new_string)\n",
    "#             for app in app_list:\n",
    "#                 final_str = new_string + '/' + app\n",
    "#                 malware_loc.append(final_str)\n",
    "#     return malware_loc\n",
    "# mal = malware_app_paths()[:7]\n",
    "# mal"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Create Data Structure (make_dataset)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "# def getAPICalls(catagory, appName, methodIDCount, invokeType)\n",
    "#     methodID = 'method_' + str(methodIDCount)\n",
    "#     methodList.append(line)\n",
    "#     catDict[catagory][appName]['Methods'][methodID] = methodList\n",
    "#     result = re.sub(pat, '', s)\n",
    "#     result = result[2:-2]\n",
    "                \n",
    "\n",
    "#gets each app name in the catagory \n",
    "\n",
    "#next steps - 1) open up directory for each app name 2) find the smali file in this directory \n",
    "\n",
    "\n",
    "patAPI = re.compile('^[^}]*}')\n",
    "patPack = re.compile('^(.*?)->')\n",
    "parChar = re.compile('[^(]*')\n",
    "\n",
    "def dataStructureHelper(catagory, appName, line, methodIDCount, catDict, invokeType):\n",
    "\n",
    "    \n",
    "    methodID = 'method_' + str(methodIDCount)\n",
    "    result = re.sub(patAPI, '', str(line))\n",
    "    apiCall = result[2:]\n",
    "    apiNoParam = re.match(parChar, apiCall)\n",
    "\n",
    "\n",
    "    apiCall = apiNoParam.group(0) + str('()')\n",
    "    package = re.search(patPack, apiCall)\n",
    "\n",
    "    catDict[catagory][appName]['Packages'][package.group(1)].append(apiCall)\n",
    "    catDict[catagory][appName]['All_APIs']['APIs'].append(apiCall)\n",
    "    catDict[catagory][appName]['Invoke_Type'][invokeType].append(apiCall)\n",
    "    catDict[catagory][appName]['Methods'][methodID].append(apiCall)\n",
    "\n",
    "\n",
    "def getUniqueAPIs(catDict, catagory, appName):\n",
    "    \n",
    "    #get the set of all APIs for an app with the same invoke type and put them into a list\n",
    "    invokeTypes = ['invoke-static', 'invoke-virtual', 'invoke-direct', 'invoke-super', 'invoke-interface']\n",
    "    \n",
    "    for invoke in invokeTypes:\n",
    "        catDict[catagory][appName]['Invoke_Type'][invoke] = list(set(catDict[catagory][appName]['Invoke_Type'][invoke]))\n",
    "    \n",
    "    #get the set of all APIs for an app that are called in the application\n",
    "    catDict[catagory][appName]['All_APIs']['APIs'] = list(set(catDict[catagory][appName]['All_APIs']['APIs']))\n",
    "    \n",
    "    #get the set of all packages in an app that are used in an application\n",
    "    for pack in catDict[catagory][appName]['Packages']:\n",
    "        catDict[catagory][appName]['Packages'][pack] = list(set(catDict[catagory][appName]['Packages'][pack]))\n",
    "        \n",
    "\n",
    "'''\n",
    "A method that creates a json object of the data structure \n",
    "\n",
    "'''    \n",
    "def createDataStructure(path):\n",
    "\n",
    "    catDict = defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: defaultdict(list))))\n",
    "\n",
    "\n",
    "    methodIDCount = 0\n",
    "    methodList = []\n",
    "    inMethod = False\n",
    "    methodID = 'method_' + str(methodIDCount)\n",
    "    \n",
    "    \n",
    "    startMethod = '.method'\n",
    "    endMethod = '.end method'\n",
    "    \n",
    "\n",
    "    \n",
    "    directDic = catagoryApps(path)\n",
    "    for catagory in directDic:\n",
    "\n",
    "        for appName in directDic[catagory]:\n",
    "            #get path of appname in dir\n",
    "            newPath = PATH + str(catagory) + '/' + str(appName) + '/' + 'smali'\n",
    "            if os.path.isdir(newPath):\n",
    "                #go into smali file and get all the .methods and .endmethods using regex\n",
    "                #assign unique id for each method (key) which will have a list of API calls for the values\n",
    "                samliFiles = glob.glob(newPath + '/**/*.smali', recursive=True)\n",
    "                #read each smali file and get the method calls \n",
    "                for file in samliFiles:\n",
    "                    f = open(file, \"r\")\n",
    "                    Lines = f.readlines()\n",
    "                    for line in Lines:\n",
    "                        if startMethod in line:\n",
    "                            inMethod = True\n",
    "\n",
    "                        if inMethod and (endMethod in line):\n",
    "                            inMethod = False\n",
    "                            methodIDCount += 1\n",
    "                            methodList = []\n",
    "\n",
    "                        if (inMethod) and ('invoke-static' in line): \n",
    "                            invokeType = 'invoke-static'\n",
    "                            dataStructureHelper(catagory, appName, line, methodIDCount, catDict, invokeType)\n",
    "\n",
    "                        if (inMethod) and ('invoke-virtual' in line):\n",
    "                            invokeType = 'invoke-virtual'\n",
    "                            dataStructureHelper(catagory, appName, line, methodIDCount, catDict, invokeType)\n",
    "\n",
    "                        if (inMethod) and ('invoke-direct' in line): \n",
    "                            invokeType = 'invoke-direct'\n",
    "                            dataStructureHelper(catagory, appName, line, methodIDCount, catDict, invokeType)\n",
    "\n",
    "                        if (inMethod) and ('invoke-super' in line): \n",
    "                            invokeType = 'invoke-super'\n",
    "                            dataStructureHelper(catagory, appName, line, methodIDCount, catDict, invokeType)\n",
    "\n",
    "                        if (inMethod) and ('invoke-interface' in line):\n",
    "                            invokeType = 'invoke-interface'\n",
    "                            dataStructureHelper(catagory, appName, line, methodIDCount, catDict, invokeType)\n",
    "\n",
    "            getUniqueAPIs(catDict, catagory, appName)\n",
    "            \n",
    "    return catDict\n",
    "\n",
    "catDict = createDataStructure(PATH)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['Ljava/lang/Integer;->intValue()',\n",
       " 'Ljava/lang/Integer;->intValue()',\n",
       " 'Ljava/lang/Math;->pow()',\n",
       " 'Ljava/lang/Math;->pow()',\n",
       " 'Ljava/lang/Math;->pow()',\n",
       " 'Ljava/lang/Math;->pow()',\n",
       " 'Ljava/lang/Math;->pow()',\n",
       " 'Ljava/lang/Math;->pow()',\n",
       " 'Ljava/lang/Math;->pow()',\n",
       " 'Ljava/lang/Math;->pow()',\n",
       " 'Ljava/lang/Math;->pow()',\n",
       " 'Ljava/lang/Math;->round()',\n",
       " 'Ljava/lang/Math;->round()',\n",
       " 'Ljava/lang/Math;->round()',\n",
       " 'Ljava/lang/Math;->round()',\n",
       " 'Ljava/lang/Integer;->valueOf()']"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Getting the APIs called in the same method for one of the codeblocks found \n",
    "# (this is for the tools catagory and the tools_31 app)\n",
    "catDict['tools']['tools_31']['Methods']['method_113']"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Get Index Locations for Matricies"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "656"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#get a list of every possible api call in all the apps and take the set of it. This will be the \n",
    "def allAPIsDataset(catDict):\n",
    "    \n",
    "    allAPIs = []\n",
    "    for catagory in catDict:\n",
    "        for appName in catDict[catagory]:\n",
    "            allAPIs = allAPIs + list(catDict[catagory][appName]['All_APIs']['APIs'])\n",
    "    allAPIs = list(set(allAPIs))\n",
    "    \n",
    "    return allAPIs\n",
    "\n",
    "# Make a new dictionary containing unique API and there index\n",
    "def uniqueDict(jsonFile):\n",
    "\n",
    "    UniqueIDAPI = {}\n",
    "    idMaker = 0\n",
    "    for i in allAPIsDataset(jsonFile):\n",
    "        UniqueIDAPI[i] = idMaker\n",
    "        idMaker += 1\n",
    "    \n",
    "    return UniqueIDAPI\n",
    "\n",
    "UniqueIDAPI = uniqueDict(catDict)\n",
    "\n",
    "#For demonstration: Show unique ID of this API in the dictionary\n",
    "UniqueIDAPI['Lde/shellfire/vpn/android/MainTabletActivity$ServerSelectSectionFragment;->getResources()']\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "27"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#get all the possible app names \n",
    "def allApps(jsonFile):\n",
    "    \n",
    "    allApps = []\n",
    "    for catagory in catDict:\n",
    "        allApps = allApps + list(catDict[catagory])\n",
    "    return allApps\n",
    "\n",
    "# Make a new dictionary containing unique apps and there index\n",
    "def UniqueApps(jsonFile): \n",
    "    \n",
    "    UniqueIDApp = {}\n",
    "    idMakerApp = 0\n",
    "    \n",
    "    for i in allApps(jsonFile):\n",
    "        UniqueIDApp[i] = idMakerApp\n",
    "        idMakerApp += 1\n",
    "    \n",
    "    return UniqueIDApp\n",
    "\n",
    "UniqueIDApp = UniqueApps(catDict)\n",
    "\n",
    "#For demonstration: Show unique ID of this app in the dictionary\n",
    "UniqueIDApp['comics_28']"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# A-Matrix, B-Matrix, P-Matrix, I-Matrix"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "IOPub data rate exceeded.\n",
      "The notebook server will temporarily stop sending output\n",
      "to the client in order to avoid crashing it.\n",
      "To change this limit, set the config variable\n",
      "`--NotebookApp.iopub_data_rate_limit`.\n",
      "\n",
      "Current values:\n",
      "NotebookApp.iopub_data_rate_limit=1000000.0 (bytes/sec)\n",
      "NotebookApp.rate_limit_window=3.0 (secs)\n",
      "\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "<52x341052 sparse matrix of type '<class 'numpy.int64'>'\n",
       "\twith 1033856 stored elements in COOrdinate format>"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Sparse MatrixA\n",
    "def aMatrixSparse(catDict):\n",
    "    \n",
    "    appIdxRows = []\n",
    "    apiIdxCols = []\n",
    "    data = []\n",
    "    \n",
    "    for catagory in catDict:\n",
    "        for appName in catDict[catagory]:\n",
    "            print(catDict[catagory][appName])\n",
    "            for api in list(catDict[catagory][appName]['All_APIs']['APIs']):\n",
    "                appIdxRows.append(UniqueIDApp[appName])\n",
    "                apiIdxCols.append(UniqueIDAPI[api])\n",
    "                data.append(1)\n",
    "                \n",
    "    return sparse.coo_matrix((data, (appIdxRows, apiIdxCols)))\n",
    "\n",
    "aMatrix = aMatrixSparse(catDict)\n",
    "aMatrix"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Find the adjacency matrix for methods that exist in the same code block MatrixB\n",
    "def bMatrixSparse(catDict):\n",
    "    \n",
    "    appIdxRows = []\n",
    "    apiIdxCols = []\n",
    "    data = []\n",
    "\n",
    "    for catagory in catDict:\n",
    "        for appName in catDict[catagory]:\n",
    "            keylist = list(catDict[catagory][appName]['Methods'].keys())\n",
    "            methodList = [[item for item in catDict[catagory][appName]['Methods'][key]] for key in keylist]\n",
    "\n",
    "            for i in methodList:\n",
    "                for j in i:\n",
    "                    for k in i:\n",
    "                        appIdxRows.append(UniqueIDAPI[j])\n",
    "                        apiIdxCols.append(UniqueIDAPI[k])\n",
    "                        data.append(1)\n",
    "                        \n",
    "                        appIdxRows.append(UniqueIDAPI[k])\n",
    "                        apiIdxCols.append(UniqueIDAPI[j])\n",
    "                        data.append(1)\n",
    "                        \n",
    "    return sparse.coo_matrix((data, (appIdxRows, apiIdxCols)))\n",
    "\n",
    "bMatrix = bMatrixSparse(catDict)\n",
    "bMatrix"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Find the adjacency matrix for methods that exist in the same package MatrixP\n",
    "def pMatrixSparse(catDict):\n",
    "    \n",
    "    appIdxRows = []\n",
    "    apiIdxCols = []\n",
    "    data = []\n",
    "\n",
    "    for catagory in catDict:\n",
    "        for appName in catDict[catagory]:\n",
    "            keylist = list(catDict[catagory][appName]['Packages'].keys())\n",
    "            packageList = [[item for item in catDict[catagory][appName]['Packages'][key]] for key in keylist]\n",
    "\n",
    "            for i in packageList:\n",
    "                for j in i:\n",
    "                    for k in i:\n",
    "                        appIdxRows.append(UniqueIDAPI[j])\n",
    "                        apiIdxCols.append(UniqueIDAPI[k])\n",
    "                        data.append(1)\n",
    "                        \n",
    "                        appIdxRows.append(UniqueIDAPI[k])\n",
    "                        apiIdxCols.append(UniqueIDAPI[j])\n",
    "                        data.append(1)\n",
    "                        \n",
    "    return sparse.coo_matrix((data, (appIdxRows, apiIdxCols)))\n",
    "\n",
    "pMatrix = pMatrixSparse(catDict)\n",
    "pMatrix"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def iMatrixSparse(catDict, UniqueIDAPI):\n",
    "\n",
    "    appIdxRows = []\n",
    "    apiIdxCols = []\n",
    "    data = []\n",
    "\n",
    "    #Find the adjacency matrix for methods that exist in the same invoke method MatrixI\n",
    "    print(\"Creating The I-Matrix....\")\n",
    "    for catagory in tqdm(catDict):\n",
    "        for appName in catDict[catagory]:\n",
    "            keylist = list(catDict[catagory][appName]['Invoke_Type'].keys())\n",
    "            invokeList = [[item for item in catDict[catagory][appName]['Invoke_Type'][key]] for key in keylist]\n",
    "\n",
    "            for i in invokeList:\n",
    "                for j in i:\n",
    "                    for k in i:\n",
    "                        appIdxRows.append(UniqueIDAPI[j])\n",
    "                        apiIdxCols.append(UniqueIDAPI[k])\n",
    "                        data.append(1)\n",
    "\n",
    "                        appIdxRows.append(UniqueIDAPI[k])\n",
    "                        apiIdxCols.append(UniqueIDAPI[j])\n",
    "                        data.append(1)\n",
    "\n",
    "    return sparse.coo_matrix((data, (appIdxRows, apiIdxCols)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Kernel multiplication\n",
    "\n",
    "# Transpose\n",
    "def trans(Matrix):\n",
    "    return Matrix.transpose()\n",
    "\n",
    "# AA^T\n",
    "def AAtrans(MatrixA, MatrixATrans):\n",
    "    return MatrixA.dot(MatrixATrans)\n",
    "\n",
    "# # ABA^T\n",
    "def ABAtrans(MatrixA, MatrixB, MatrixATrans):\n",
    "    AdotB = MatrixA.dot(MatrixB)\n",
    "    return AdotB.dot(MatrixATrans)\n",
    "\n",
    "# # APA^T\n",
    "def APAtrans(MatrixA, MatrixP, MatrixATrans):\n",
    "    AdotP = MatrixA.dot(MatrixP)\n",
    "    return AdotP.dot(MatrixATrans)\n",
    "\n",
    "# APBP^TA^T\n",
    "def APBPtransAtrans(MatrixA, MatrixB, MatrixP, MatrixATrans, MatrixPTrans):\n",
    "    AdotP = MatrixA.dot(MatrixP)\n",
    "    AdotPdotB = AdotP.dot(MatrixB)\n",
    "    prevDotPtrans = AdotPdotB.dot(MatrixPTrans)\n",
    "    prevDotAtrans = prevDotPtrans.dot(MatrixATrans)\n",
    "    return prevDotAtrans\n",
    "    \n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def createSVM(ker):\n",
    "    \n",
    "    df = pd.DataFrame(ker)\n",
    "    df['Classification_id'] = UniqueIDApp.keys()\n",
    "    df['Classification_id'] = df['Classification_id'].apply(lambda x: 'malware' if 'Malware' in x else 'benign')\n",
    "\n",
    "    feature_cols = df.iloc[:,:-1]\n",
    "    X = feature_cols # Features\n",
    "    y = df['Classification_id'] # Target variable\n",
    "    \n",
    "    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25, random_state = 42)\n",
    "    clf = LinearSVC(random_state=0, tol=1e-5)\n",
    "    clf.fit(X_train, y_train)\n",
    "    clf.score(X_test, y_test)\n",
    "    accuracy = fitted.score(X_test, y_test)\n",
    "    print('----------------------------------------------------------')\n",
    "    print('Accuracy:  ' + str(accuracy))\n",
    "    print('----------------------------------------------------------')\n",
    "    f1 = f1_score(y_test, pred, average='weighted')\n",
    "    print('F1_score:  ' + str(f1))\n",
    "    tn, fp, fn, tp = confusion_matrix(y_test, pred).ravel()\n",
    "    print('Confusion_matrix')\n",
    "    print('----------------------------------------------------------')\n",
    "    print('tn: ' + str(tn) + '  |  fp: ' + str(fp) + '  |  tn: ' + str(tn) + '  |  tp: ' + str(tp))\n",
    "    return accuracy\n",
    "\n",
    "print('AA^T')\n",
    "createSVM(AAtrans(aMatrix, aMatrix.T).toarray())\n",
    "print('----------------------------------------------------------')\n",
    "print('\\n')\n",
    "print('ABA^T')\n",
    "createSVM(ABAtrans(aMatrix, bMatrix, aMatrix.T).toarray())\n",
    "print('----------------------------------------------------------')\n",
    "print('\\n')\n",
    "print('APA^T')\n",
    "createSVM(APAtrans(aMatrix, pMatrix, aMatrix.T).toarray())\n",
    "print('----------------------------------------------------------')\n",
    "print('\\n')\n",
    "print('APBP^TA^T')\n",
    "createSVM(APBPtransAtrans(aMatrix, bMatrix, pMatrix, aMatrix.T, pMatrix.T).toarray())\n",
    "print('----------------------------------------------------------')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# EDA and Baseline model (Improved from Assignment 2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Unique API count by Catagory\n",
      "\n",
      "totalNumUniqueTools: 198806\n",
      "\n",
      "totalNumUniqueComics: 219463\n",
      "\n",
      "avgUniqueTools: 7952.24\n",
      "\n",
      "avgUniqueComics: 8778.52\n",
      "\n",
      "----------------------------------------------------\n",
      "\n",
      "Number of Packages by type per catagory\n",
      "\n",
      "totalNumPackTools: 337325\n",
      "\n",
      "totalNumPackComics: 696531\n",
      "\n",
      "avgUniquePackTools: 13493.0\n",
      "\n",
      "avgUniquePackComics: 27861.24\n",
      "\n",
      "----------------------------------------------------\n",
      "\n",
      "Average number of API calls by invoke type\n",
      "\n",
      "staticToolsAvg: 2137.44\n",
      "\n",
      "virtualToolsAvg: 6616.64\n",
      "\n",
      "directToolsAvg: 3483.2\n",
      "\n",
      "superToolsAvg: 442.64\n",
      "\n",
      "interfaceToolsAvg: 1308.84\n",
      "\n",
      "----------------------------------------------------\n",
      "\n",
      "staticComicsAvg: 4862.72\n",
      "\n",
      "virtualComicsAvg: 13356.8\n",
      "\n",
      "directComicsAvg: 7265.48\n",
      "\n",
      "superComicsAvg: 741.08\n",
      "\n",
      "interfaceComicsAvg: 2514.2\n",
      "\n",
      "----------------------------------------------------\n",
      "\n"
     ]
    }
   ],
   "source": [
    "### Get the number of unique API calls \n",
    "catagory1 = 'tools'\n",
    "catagory2 = 'comics'\n",
    "\n",
    "numCat = countBenign(directDic)/2 - 1\n",
    "catagory1Count = int(numCat)\n",
    "catagory2Count = int(numCat)\n",
    "\n",
    "cat1List = []\n",
    "cat2List = []\n",
    "cat1CountAPI = []\n",
    "cat2CountAPI = []\n",
    "cat1Pack = []\n",
    "cat2Pack = []\n",
    "cat1ListPack = 0\n",
    "cat2ListPack = 0\n",
    "\n",
    "cat1Static = 0\n",
    "cat1Virtual = 0\n",
    "cat1Direct = 0\n",
    "cat1Super = 0\n",
    "cat1Inter = 0\n",
    "\n",
    "cat2Static = 0\n",
    "cat2Virtual = 0\n",
    "cat2Direct = 0\n",
    "cat2Super = 0\n",
    "cat2Inter = 0\n",
    "\n",
    "invokeTypes = ['invoke-static', 'invoke-virtual', 'invoke-direct', 'invoke-super', 'invoke-interface']\n",
    "\n",
    "for appName in catDict[catagory1]:\n",
    "    cat1List = cat1List + list(catDict[catagory1][appName]['All_APIs']['APIs'])\n",
    "    cat1CountAPI.append(len(list(catDict[catagory1][appName]['All_APIs']['APIs'])))\n",
    "\n",
    "cat1List = set(cat1List)\n",
    "\n",
    "\n",
    "\n",
    "for appName in catDict[catagory2]:\n",
    "    cat2List = cat2List + list(catDict[catagory2][appName]['All_APIs']['APIs'])\n",
    "    cat2CountAPI.append(len(list(catDict[catagory2][appName]['All_APIs']['APIs'])))\n",
    "cat2List = set(cat2List)\n",
    "\n",
    "\n",
    "\n",
    "totalNumUnique1 = len(cat1List)\n",
    "totalNumUnique2 = len(cat2List)\n",
    "\n",
    "print('Unique API count by Catagory\\n')\n",
    "\n",
    "print('totalNumUniqueTools: ' + str(totalNumUnique1) +'\\n')\n",
    "print('totalNumUniqueComics: ' + str(totalNumUnique2) +'\\n')\n",
    "\n",
    "avgUnique1 = totalNumUnique1 / catagory1Count\n",
    "avgUnique2 = totalNumUnique2 / catagory2Count\n",
    "\n",
    "print('avgUniqueTools: ' + str(avgUnique1) +'\\n')\n",
    "print('avgUniqueComics: ' + str(avgUnique2) +'\\n')\n",
    "print('----------------------------------------------------\\n')\n",
    "\n",
    "### Get the total number of Packages\n",
    "print('Number of Packages by type per catagory\\n')\n",
    "for appName in catDict[catagory1]:\n",
    "    for pack in catDict[catagory1][appName]['Packages']:\n",
    "        cat1ListPack = cat1ListPack + len(list(catDict[catagory1][appName]['Packages'][pack]))\n",
    "        cat1Pack.append(len((catDict[catagory1][appName]['Packages'][pack])))\n",
    "\n",
    "\n",
    "for appName in catDict[catagory2]:\n",
    "     for pack in catDict[catagory2][appName]['Packages']:\n",
    "        cat2ListPack = cat2ListPack + len(list(catDict[catagory2][appName]['Packages'][pack]))\n",
    "        cat2Pack.append(len((catDict[catagory2][appName]['Packages'][pack])))\n",
    "\n",
    "\n",
    "\n",
    "totalNumPack1 = cat1ListPack\n",
    "totalNumPack2 = cat2ListPack\n",
    "\n",
    "print('totalNumPackTools: ' + str(totalNumPack1) +'\\n')\n",
    "print('totalNumPackComics: ' + str(totalNumPack2) +'\\n')\n",
    "\n",
    "avgUniquePack1 = totalNumPack1 / catagory1Count\n",
    "avgUniquePack2 = totalNumPack2 / catagory2Count\n",
    "\n",
    "print('avgUniquePackTools: ' + str(avgUniquePack1) +'\\n')\n",
    "print('avgUniquePackComics: ' + str(avgUniquePack2) +'\\n')\n",
    "print('----------------------------------------------------\\n')\n",
    "### Number of API calls by type per catagory\n",
    "\n",
    "for appName in catDict[catagory1]:\n",
    "\n",
    "    cat1Static = cat1Static + len(list(catDict[catagory1][appName]['Invoke_Type']['invoke-static']))\n",
    "    cat1Virtual = cat1Virtual + len(list(catDict[catagory1][appName]['Invoke_Type']['invoke-virtual']))\n",
    "    cat1Direct = cat1Direct + len(list(catDict[catagory1][appName]['Invoke_Type']['invoke-direct']))\n",
    "    cat1Super = cat1Super + len(list(catDict[catagory1][appName]['Invoke_Type']['invoke-super']))\n",
    "    cat1Inter = cat1Inter + len(list(catDict[catagory1][appName]['Invoke_Type']['invoke-interface']))\n",
    "\n",
    "for appName in catDict[catagory2]:\n",
    "\n",
    "    cat2Static = cat2Static + len(list(catDict[catagory2][appName]['Invoke_Type']['invoke-static']))\n",
    "    cat2Virtual = cat2Virtual + len(list(catDict[catagory2][appName]['Invoke_Type']['invoke-virtual']))\n",
    "    cat2Direct = cat2Direct + len(list(catDict[catagory2][appName]['Invoke_Type']['invoke-direct']))\n",
    "    cat2Super = cat2Super + len(list(catDict[catagory2][appName]['Invoke_Type']['invoke-super']))\n",
    "    cat2Inter = cat2Inter + len(list(catDict[catagory2][appName]['Invoke_Type']['invoke-interface']))\n",
    "\n",
    "### Average number of API calls by invoke type \n",
    "\n",
    "static1Avg = cat1Static / catagory1Count\n",
    "virtual1Avg = cat1Virtual / catagory1Count\n",
    "direct1Avg = cat1Direct / catagory1Count\n",
    "super1Avg = cat1Super / catagory1Count\n",
    "interface1Avg = cat1Inter / catagory1Count\n",
    "\n",
    "static2Avg = cat2Static / catagory2Count\n",
    "virtual2Avg = cat2Virtual / catagory2Count\n",
    "direct2Avg = cat2Direct / catagory2Count\n",
    "super2Avg = cat2Super / catagory2Count\n",
    "interface2Avg = cat2Inter / catagory2Count\n",
    "\n",
    "print('Average number of API calls by invoke type\\n')\n",
    "print('staticToolsAvg: ' + str(static1Avg) +'\\n')\n",
    "print('virtualToolsAvg: ' + str(virtual1Avg) +'\\n')\n",
    "print('directToolsAvg: ' + str(direct1Avg) +'\\n')\n",
    "print('superToolsAvg: ' + str(super1Avg) +'\\n')\n",
    "print('interfaceToolsAvg: ' + str(interface1Avg) +'\\n')\n",
    "print('----------------------------------------------------\\n')\n",
    "\n",
    "print('staticComicsAvg: ' + str(static2Avg) +'\\n')\n",
    "print('virtualComicsAvg: ' + str(virtual2Avg) +'\\n')\n",
    "print('directComicsAvg: ' + str(direct2Avg) +'\\n')\n",
    "print('superComicsAvg: ' + str(super2Avg) +'\\n')\n",
    "print('interfaceComicsAvg: ' + str(interface2Avg) +'\\n')\n",
    "print('----------------------------------------------------\\n')\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Text(0.5, 1.0, 'Number of APIs for the comics catagory by App')"
      ]
     },
     "execution_count": 85,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.hist(cat2CountAPI, bins=30)\n",
    "plt.xlabel(\"Number of Unique APIs\")\n",
    "plt.title('Number of APIs for the comics catagory by App')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Text(0.5, 1.0, 'Number of APIs for the tools catagory by App')"
      ]
     },
     "execution_count": 86,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.hist(cat1CountAPI, bins=30)\n",
    "plt.xlabel(\"Number of Unique APIs\")\n",
    "plt.title('Number of APIs for the tools catagory by App')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create a Baseline Model to classify type of app catagory based on there invoke type counts and there number of unique packages\n",
    "catagory = [0,0,0,0,1,1,1,1,1,1,1,1,1]\n",
    "staticBeautyLi = []\n",
    "virtualBeautyLi = []\n",
    "directBeautyLi = []\n",
    "superBeautyLi = []\n",
    "interfaceBeautyLi = []\n",
    "\n",
    "staticComicsLi = []\n",
    "virtualComicsLi = []\n",
    "directComicsLi = []\n",
    "superComicsLi = []\n",
    "interfaceComicsLi = []\n",
    "\n",
    "uniqueComicPack = []\n",
    "uniqueBeautyPack = []\n",
    "\n",
    "comicsAppName = []\n",
    "beautyAppName = []\n",
    "\n",
    "for appName in catDict['comics']:\n",
    "    superComicsLi.append(len(list(catDict['comics'][appName]['Invoke_Type']['invoke-super'])))\n",
    "    interfaceComicsLi.append(len(list(catDict['comics'][appName]['Invoke_Type']['invoke-interface'])))\n",
    "    directComicsLi.append(len(list(catDict['comics'][appName]['Invoke_Type']['invoke-direct'])))\n",
    "    virtualComicsLi.append(len(list(catDict['comics'][appName]['Invoke_Type']['invoke-virtual'])))\n",
    "    staticComicsLi.append(len(list(catDict['comics'][appName]['Invoke_Type']['invoke-static'])))\n",
    "    comicsAppName.append(appName)\n",
    "    \n",
    "for appName in catDict['beauty']:\n",
    "    superBeautyLi.append(len(list(catDict['beauty'][appName]['Invoke_Type']['invoke-super'])))\n",
    "    interfaceBeautyLi.append(len(list(catDict['beauty'][appName]['Invoke_Type']['invoke-interface'])))\n",
    "    directBeautyLi.append(len(list(catDict['beauty'][appName]['Invoke_Type']['invoke-direct'])))\n",
    "    virtualBeautyLi.append(len(list(catDict['beauty'][appName]['Invoke_Type']['invoke-virtual'])))\n",
    "    staticBeautyLi.append(len(list(catDict['beauty'][appName]['Invoke_Type']['invoke-static'])))\n",
    "    beautyAppName.append(appName)\n",
    "    \n",
    "interfaceBeautyLi = interfaceBeautyLi[:4]\n",
    "directBeautyLi = directBeautyLi[:4]\n",
    "virtualBeautyLi = virtualBeautyLi[:4]\n",
    "staticBeautyLi = staticBeautyLi[:4]\n",
    "superBeautyLi = superBeautyLi[:4]\n",
    "beautyAppName = beautyAppName[:4] \n",
    "\n",
    "\n",
    "comicsAppName = comicsAppName[1:10]\n",
    "superComicsLi = superComicsLi[1:10]\n",
    "interfaceComicsLi = interfaceComicsLi[1:10]\n",
    "directComicsLi = directComicsLi[1:10]\n",
    "virtualComicsLi = virtualComicsLi[1:10]\n",
    "staticComicsLi = staticComicsLi[1:10]\n",
    "\n",
    "beautyAppName = beautyAppName + comicsAppName\n",
    "interfaceBeautyLi = interfaceBeautyLi + interfaceComicsLi\n",
    "directBeautyLi = directBeautyLi + directComicsLi\n",
    "virtualBeautyLi = virtualBeautyLi + virtualComicsLi\n",
    "superBeautyLi = superBeautyLi + superComicsLi\n",
    "staticBeautyLi = staticBeautyLi + staticComicsLi\n",
    "\n",
    "\n",
    "\n",
    "df = pd.DataFrame()\n",
    "df['AppName'] = beautyAppName\n",
    "df['Interface Invoke'] = interfaceBeautyLi\n",
    "df['Direct Invoke'] = directBeautyLi\n",
    "df['Virtual Invoke'] = virtualBeautyLi\n",
    "df['Super Invoke'] = superBeautyLi\n",
    "df['Static Invoke'] = staticBeautyLi\n",
    "df['label'] = catagory\n",
    "df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "feature_cols = ['Interface Invoke', 'Direct Invoke', 'Virtual Invoke', 'Super Invoke','Static Invoke']\n",
    "X = df[feature_cols] # Features\n",
    "y = df.label # Target variable\n",
    "\n",
    "logreg = RandomForestClassifier()\n",
    "fitted = logreg.fit(X,y)\n",
    "pred = fitted.predict(X)\n",
    "fitted.score(X,y)\n",
    "f1 = f1_score(y, pred, average='weighted')\n",
    "f1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "x = defaultdict(lambda: defaultdict(lambda: defaultdict(lambda: defaultdict(list))))\n",
    "\n",
    "x['outer']['appname']['Invoke_Type']['invoke-virtual'].append('sdf')\n",
    "x['outer']['appname']['Invoke_Type']['invoke-virtual'] = set(x['outer']['appname']['Invoke_Type']['invoke-virtual'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "line = 'Landroid/text/StaticLayout;->getHeight()'\n",
    "patPack = re.compile('(.+?);')\n",
    "res = re.match(patPack, line)\n",
    "type(res.group(1))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "p = '/Users/kelkin/Documents/DSC_180A/APK_Downloads/comics/comics_3/smali/com/squareup/picasso/Utils.smali'\n",
    "\n",
    "file1 = open(p, 'r') \n",
    "Lines = file1.readlines() \n",
    "inMethod = False  \n",
    "count = 0\n",
    "startMethod = '.method'\n",
    "endMethod = '.end method'\n",
    "# Strips the newline character \n",
    "for line in Lines: \n",
    "    if startMethod in line:\n",
    "        inMethod = True\n",
    "    if inMethod:\n",
    "        \n",
    "    print(line.strip()) \n",
    "    print(\"Line{}: {}\".format(count, line.strip())) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''\n",
    "{\n",
    "    catagory:\n",
    "            {\n",
    "                appName:\n",
    "                        {\n",
    "                            Packages: {\n",
    "                                      pack_1: [API1, API2, ...] \n",
    "                                      pack_2: [API1, API2, ...]  \n",
    "                                      .....\n",
    "                                      }\n",
    "                            \n",
    "                            Methods:\n",
    "                                    {\n",
    "                                      method_1: [API1, API2, ...] \n",
    "                                      method_2: [API1, API2, ...]  \n",
    "                                      .....\n",
    "                                    }\n",
    "                            \n",
    "                            Invoke Type:\n",
    "                                    {\n",
    "                                      invoke_super: [API1, API2, ...]\n",
    "                                      invoke_virtual: [API1, API2, ...]\n",
    "                                    }\n",
    "                            All_APIs: [API1, API2, ...]\n",
    "                        }\n",
    "            }\n",
    "    \n",
    "    \n",
    "    \n",
    "}\n",
    "'''"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
